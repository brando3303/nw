const { Client } = require('@notionhq/client');

/*
player := {
    id, // generated by db
    name,
    position,
    score,
    playerpage,
    playerpage_prev,
    date_edited,
    player_img,
    team_img
}
*/

/* usage: create a new NotionHelper, call getData, and then
 * processData to get the complete player data for 
 * placing into the database
 */
class NotionHelper {
    constructor(notion_key) {
        this.notion_key = notion_key;
        this.data = null;

        this.notion = new Client({ auth: notion_key });
    }

    // populates the data field of this NotionHelper. 
    getData = async () => {
        this.data = await this.searchRootAll(20);
        console.log(this.data)
        this.data = this.processSearchData(this.data)
    }

    // processes the data into a Player list and returns it. 
    processData = async () => {
        console.log(this.data)
        return await this.positionListToPlayerList(this.data.positions);
    }

    // post search notion root num_pages times. places all results into an array and returns it.
    searchRootAll = async (num_pages) => {
        let has_more = true;
        let results = [];
        let start_cursor = undefined;
        for (let i = 0; has_more && i < num_pages; i++) {
            console.log("new call, res len: " + results.length);
            const response = await this.notion.search({
                //query: '2025',
                // filter: {
                //     value: 'page',
                //     property: 'object'
                // },
                sort: {
                    direction: 'ascending',
                    timestamp: 'last_edited_time'
                },
                start_cursor: start_cursor,
            });
            //_printNames(response.results);
            //console.log("current response len: " + response.results.length);
            has_more = response.has_more;
            results = results.concat(response.results);
            start_cursor = response.next_cursor;
        }

        return results;
    }

    // takes search data and places it into the required
    // data structure (2025 -> positions -> players -> (name, ...))
    processSearchData = (searchResults) => {
        // check that the input is correct
        if (!Array.isArray(searchResults)) {
            console.error("processSearchData: passed argument was not an array");
            return null;
        };

        let processed = {positions:[]};
        // 1) find 2025 (ttf), get pageId
        let ttfPage = this.getPageInSearchTitle(searchResults, "2025");
        let ttfPageId = ttfPage.id;
        // 2) fill in the data structure
        for (let i = 0; i < searchResults.length; i++) {
            let position = searchResults[i];
            if(position.parent.page_id === ttfPageId) {
                //populate this position
                let positionEntry = {positionName: this.getPageTitle(position),
                                    pageId: position.id,
                                    players: []
                                    }

                //found a position page, next find all children (players)
                //searchResults = searchResults.splice(i,1);
                for (let j = 0; j < searchResults.length; j++) {
                    let player = searchResults[j];
                    if (player.parent.page_id === positionEntry.pageId) {
                        //console.log(JSON.stringify(player, null, 2));
                        //need to check if name has a score...
                        let s = this.hasScore(this.getPageTitle(player))
                        if (s !== null) {
                            console.log(s);
                            // found a child (player), populate and add to position
                            let playerEntry = 
                            {
                                name: s[0],
                                score: s[1],
                                pageId: player.id,
                                parentPageId: player.parent.page_id,
                                player_img: player.cover.external.url,
                                team_img: player.icon.file.url,
                                date_edited: player.last_edited_time,
                            }
                            if (this.getPageTitle(player) == "Cam Ward (85)") {
                                console.log(JSON.stringify(player, null, 2));
                            }
                            positionEntry.players.push(playerEntry);
                        }


                    }
                }
                processed.positions.push(positionEntry);
            }
        }

        return processed;
    }

    // finds and returns the search result profile of a 
    // page with the specified title. returns null if does 
    // not exist.
    getPageInSearchTitle = (searchResults, title) => {
        for (let p of searchResults) {
            if (p.properties.title.title[0].text.content === title) {
                return p;
            }
        }
        return null;
    }


    // requires page is a notion page. returns the page's title
    getPageTitle = (page) => {
        return page.properties.title.title[0].text.content;
    }

    positionListToPlayerList = async (positions) => {
        const list = [];
        for (let pos of positions) {
            for (let player of pos.players) {
                if (player.name == null || pos.positionName == null ||player.pageId == null) {
                    console.log(player.name + pos.positionName + playerPageToHTML(player.pageId));
                }
                if (typeof player.name ==='string' && typeof pos.positionName === 'string'){
                    const playerpage = await this.playerPageToHTML(player.pageId)
                    list.push({
                        name: player.name,
                        position: pos.positionName,
                        score: player.score,
                        player_img: player.player_img,
                        team_img: player.team_img,
                        date_edited: player.date_edited,
                        playerpage: playerpage,
                        playerpage_prev: playerpage.slice(0, 100) + "...",
                    });
                }
            }
        }   
        return list;
    }

    // creates an HTML page from the contents of the page pageId refers to.
    // currently limited to 100 blocks. supports paragraphs and bullet lists.
    // returns null if error occurs (silently haha). returns a string containing
    // HTML
    playerPageToHTML = async (pageId) => {
        // get notion page connected to player
        const page = await this.notion.blocks.children.list({
            block_id: pageId,
            page_size: 100,
        });
        //console.log(JSON.stringify(page, null, 2));
        // iterate through player page and compile blocks into HTML
        let outHTML = "<div>";
        let bulleted = false;
        for (let block of page.results) {
            if (block.type === "paragraph") {
                if(bulleted) {
                    bulleted = false;
                    outHTML += "</ul>";
                }
                outHTML += "<p>" + this.getParagraph(block) + "</p>";
            } else if (block.type === "bulleted_list_item") {
                if(!bulleted) {
                    bulleted = true;
                    outHTML += "<ul>";
                }
                if (block.bulleted_list_item.rich_text != null && block.bulleted_list_item.rich_text[0] != null && 
                    block.bulleted_list_item.rich_text[0].plain_text != null) {
                    outHTML += "<li>" + block.bulleted_list_item.rich_text[0].plain_text + "</li>";
                }
            }
        }
        outHTML += "</div>"
        return outHTML;
    }

    // gets the text paragraph from a text block
    getParagraph = (block) => {
        if (block.type !== "paragraph") return null;
        if (block.paragraph.rich_text != null && block.paragraph.rich_text[0] != null && 
            block.paragraph.rich_text[0].plain_text != null) {
            return block.paragraph.rich_text[0].plain_text === undefined ? "" : block.paragraph.rich_text[0].plain_text;
        }
    }

    // checks if the title has a score <name (score)>. if
    // there is no score, returns null. other wise returns 
    // [name, score]
    hasScore = (title) => {
        let title_s = title.split(" ");
        if (title_s.length < 2) {return null;}
        let score = title_s.at(-1);
        score = score.substring(1, score.length - 1);
        if (isNaN(score) || score.length < 1) { return null;}
        return [title_s.slice(0, -1).join(" "), Number(score)];
    }
}

module.exports ={
    NotionHelper
}

